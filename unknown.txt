import cantools
import cantools.database
import cantools.database.conversion
import numpy as np
import pandas as pd
from cantools.database.can.formats.dbc import DbcSpecifics
from collections import defaultdict
import re
import logging
from typing import Dict, List, Optional, Union

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DBCGenerator:
    """Класс для генерации DBC файла из Excel таблицы."""
    
    def __init__(self, excel_path: str):
        """
        Инициализация генератора DBC.
        
        Args:
            excel_path: Путь к Excel файлу с описанием CAN матрицы
        """
        self.excel_path = excel_path
        self.db = cantools.database.can.Database(version="V5.0.0")
        self.db.dbc = DbcSpecifics()
        self.bus_users = ["SGW_SG", "CGW_SG"]
        
    def load_data(self) -> pd.DataFrame:
        """Загрузка данных из Excel файла."""
        try:
            with pd.ExcelFile(self.excel_path, engine="openpyxl") as xls:
                df = pd.read_excel(xls, sheet_name="Matrix", keep_default_na=True)
                df_history = pd.read_excel(xls, sheet_name="History", keep_default_na=True)
            
            df_history = df_history.reindex(df.index)

            new_df = pd.DataFrame({
                "Message ID": df["Msg ID\n报文标识符"],
                "Message Name": df["Msg Name\n报文名称"],
                "Signal Name": df["Signal Name\n信号名称"],
                "Start Byte": df["Start Byte\n起始字节"],
                "Start Bit": df["Start Bit\n起始位"],
                "Length": df["Bit Length (Bit)\n信号长度"],
                "Factor": df["Resolution\n精度"],
                "Offset": df["Offset\n偏移量"],
                "Initial": df["Initial Value (Hex)\n初始值"],
                "Invalid": df["Invalid Value(Hex)\n无效值"],
                "Min": df["Signal Min. Value (phys)\n物理最小值"],
                "Max": df["Signal Max. Value (phys)\n物理最大值"],
                "Unit": df["Unit\n单位"],
                "Receiver": np.where(df["SGW_SG"] == "R", "SGW_SG", "CGW_SG"),
                "Byte Order": df["Byte Order\n排列格式(Intel/Motorola)"],
                "Data Type": df["Data Type\n数据类型"],
                "Cycle Type": df["Msg Cycle Time (ms)\n报文周期时间"],
                "Send Type": df["Msg Send Type\n报文发送类型"],
                "Description": df["Signal Description\n信号描述"],
                "Signal Value Description": df["Signal Value Description\n信号值描述"],
                "Senders": np.where(df["SGW_SG"] == "S", "SGW_SG", "CGW_SG"),
                "Revision": df_history["Revision Management\n版本管理"].apply(
                    lambda x: x.split("版本")[-1] if pd.notna(x) else x)
            })

            new_df["Message Name"] = new_df["Message Name"].ffill()
            new_df["Message ID"] = new_df["Message ID"].ffill()
            new_df = new_df.dropna(subset=["Signal Name"])
            new_df["Is Signed"] = new_df["Data Type"].str.contains("Signed", na=False)
            
            return new_df
        
        except Exception as e:
            logger.error(f"Ошибка загрузки данных из Excel: {str(e)}")
            raise

    @staticmethod
    def calculate_start_bit(start_byte: int, start_bit: int, byte_order: str, length: int) -> int:
        """Вычисление стартового бита с учетом порядка байтов и длины сигнала."""
        if byte_order.lower() == "motorola":
            return (start_byte * 8) + (7 - (start_bit % 8))
        return (start_byte * 8) + start_bit

    @staticmethod
    def calculate_message_length(signals: List[cantools.database.can.Signal]) -> int:
        """Вычисление минимальной длины сообщения для всех сигналов."""
        max_bit = 0
        for signal in signals:
            end_bit = signal.start + signal.length
            max_bit = max(max_bit, end_bit)
        return (max_bit + 7) // 8

    @staticmethod
    def parse_value_descriptions(desc_str: str) -> Optional[Dict[int, str]]:
        """Парсинг описаний значений сигналов."""
        if not isinstance(desc_str, str) or not desc_str.strip():
            return None
        
        descriptions = {}
        try:
            desc_str = ' '.join(desc_str.replace('\r', '\n').split())

            parts = re.split(r'(0x[0-9a-fA-F]+)\s*:\s*', desc_str)
            if len(parts) > 1:
                for i in range(1, len(parts), 2):
                    hex_val = parts[i]
                    text = parts[i+1].split(';')[0].split('~')[0].strip()
                    text = re.sub(r'[^a-zA-Z0-9_\- ]', '', text)
                    if hex_val and text:
                        try:
                            dec_val = int(hex_val, 16)
                            descriptions[dec_val] = text
                        except ValueError:
                            continue

            range_matches = re.finditer(
                r'(0x[0-9a-fA-F]+)\s*~\s*(0x[0-9a-fA-F]+)\s*:\s*([^;]+)', 
                desc_str
            )
            for match in range_matches:
                start = int(match.group(1), 16)
                end = int(match.group(2), 16)
                text = match.group(3).strip()
                for val in range(start, end + 1):
                    descriptions[val] = text
            
            return dict(sorted(descriptions.items())) if descriptions else None
        
        except Exception as e:
            logger.warning(f"Ошибка парсинга описаний значений '{desc_str}': {str(e)}")
            return None

    def check_bit_overlaps(self, signals: List[cantools.database.can.Signal]) -> bool:
        """Проверка на перекрытие битов сигналами."""
        used_bits = defaultdict(list)
        for signal in signals:
            start = signal.start
            end = start + signal.length
            for bit in range(start, end):
                used_bits[bit].append(signal.name)
        
        overlaps = {bit: signals for bit, signals in used_bits.items() if len(signals) > 1}
        if overlaps:
            for bit, signals in overlaps.items():
                logger.warning(f"Перекрытие битов: бит {bit} используется в сигналах: {', '.join(signals)}")
            return True
        return False

    def create_signal(self, row: pd.Series) -> Optional[cantools.database.can.Signal]:
        """Создание объекта сигнала из строки DataFrame."""
        try:
            byte_order = "motorola" if row["Byte Order"] == "Motorola MSB" else "intel"
            start_bit = self.calculate_start_bit(
                int(row["Start Byte"]),
                int(row["Start Bit"]),
                byte_order,
                int(row["Length"])
            )

            is_float = "Float" in str(row["Data Type"]) if pd.notna(row["Data Type"]) else False

            value_descriptions = None
            if pd.notna(row["Signal Value Description"]):
                value_descriptions = self.parse_value_descriptions(row["Signal Value Description"])

            initial_value = 0
            if pd.notna(row["Initial"]):
                try:
                    if isinstance(row["Initial"], str) and row["Initial"].startswith("0x"):
                        initial_value = float(int(row["Initial"], 16))
                    else:
                        initial_value = float(row["Initial"])
                except (ValueError, TypeError):
                    logger.warning(f"Некорректное начальное значение для сигнала {row['Signal Name']}: {row['Initial']}")

            signal = cantools.database.can.Signal(
                name=str(row["Signal Name"]),
                start=start_bit,
                length=int(row["Length"]),
                byte_order=byte_order,
                is_signed=bool(row["Is Signed"]),
                raw_initial=initial_value,
                raw_invalid=float(int(row["Invalid"], 16)) if pd.notna(row["Invalid"]) else None,
                conversion=cantools.database.conversion.LinearConversion(
                    scale=float(row["Factor"]) if pd.notna(row["Factor"]) else 1.0,
                    offset=float(row["Offset"]) if pd.notna(row["Offset"]) else 0.0,
                    is_float=is_float
                ),
                comment=str(row["Description"]) if pd.notna(row["Description"]) else "",
                minimum=float(row["Min"]) if pd.notna(row["Min"]) else None,
                maximum=float(row["Max"]) if pd.notna(row["Max"]) else None,
                unit=str(row["Unit"]) if pd.notna(row["Unit"]) else "",
                receivers=[str(row["Receiver"])] if pd.notna(row["Receiver"]) else [],
                is_multiplexer=False
            )

            if value_descriptions:
                signal.choices = value_descriptions
            
            return signal
        
        except Exception as e:
            logger.error(f"Ошибка создания сигнала {row['Signal Name']}: {str(e)}")
            return None

    def create_message(self, msg_id: Union[str, int], msg_name: str, group: pd.DataFrame) -> bool:
        """Создание CAN сообщения из группы сигналов."""
        try:
            frame_id = int(msg_id, 16) if isinstance(msg_id, str) and msg_id.startswith("0x") else int(msg_id)

            signals = []
            for _, row in group.iterrows():
                signal = self.create_signal(row)
                if signal:
                    signals.append(signal)
            
            if not signals:
                logger.warning(f"Нет валидных сигналов для сообщения {msg_name} (0x{frame_id:X})")
                return False

            if self.check_bit_overlaps(signals):
                logger.warning(f"Пропуск сообщения {msg_name} (0x{frame_id:X}) из-за перекрытия битов")
                return False

            message_length = self.calculate_message_length(signals)
            
            # Получение общих атрибутов сообщения (из первой строки группы)
            first_row = group.iloc[0]

            message = cantools.database.can.Message(
                frame_id=frame_id,
                name=str(msg_name),
                length=message_length,
                signals=signals,
                sort_signals=None,
                cycle_time=int(first_row["Cycle Type"]) if pd.notna(first_row["Cycle Type"]) else None,
                is_extended_frame=False,
                senders=[str(first_row["Senders"])] if pd.notna(first_row["Senders"]) else [],
                is_fd=True,
                bus_name="SGW-CGW",
                protocol="CANFD",
                send_type=first_row["Send Type"] if pd.notna(first_row["Send Type"]) else None,
                comment=None
            )
            
            self.db.messages.append(message)
            return True
        
        except Exception as e:
            logger.error(f"Ошибка создания сообщения {msg_name}: {str(e)}")
            return False

    def generate_dbc(self, output_file: str) -> bool:
        """Генерация DBC файла."""
        try:
            df = self.load_data()
            
            # Добавление узлов (нод)
            nodes = [cantools.database.can.Node(name=bus_name) for bus_name in self.bus_users]
            self.db.nodes.extend(nodes)

            grouped = df.groupby(["Message ID", "Message Name"])

            success_count = 0
            for (msg_id, msg_name), group in grouped:
                if self.create_message(msg_id, msg_name, group):
                    success_count += 1
            
            logger.info(f"Успешно создано {success_count} сообщений из {len(grouped)}")

            all_revisions = df['Revision'].dropna()
            global_comment = 'CM_ "' + ',\n'.join(f'Revision:{rev}' for rev in all_revisions) + '";\n'
            
            cantools.database.dump_file(self.db, output_file)
            
            with open(output_file, "a", encoding='utf-8') as f:
                f.write("\n")
                f.write(global_comment)
            
            logger.info(f"DBC файл успешно создан: {output_file}")
            return True
        
        except Exception as e:
            logger.error(f"Ошибка генерации DBC файла: {str(e)}")
            return False

if __name__ == "__main__":

    generator = DBCGenerator(
        "C:\\projects\\ATOM\\convert2dbc\\ATOM_CANFD_Matrix_SGW-CGW_V5.0.0_20250123.xlsx"
    )
    generator.generate_dbc("output.dbc")